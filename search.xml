<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多项式</title>
      <link href="//post/poly/"/>
      <url>//post/poly/</url>
      
        <content type="html"><![CDATA[<h2 id="快速傅里叶变换（FFT）"><a href="#快速傅里叶变换（FFT）" class="headerlink" title="快速傅里叶变换（FFT）"></a>快速傅里叶变换（FFT）</h2><p>前置知识：复数、单位根。</p><p>FFT 用于计算两个多项式的乘法。其时间复杂度为 $O(n\log n)$。</p><h3 id="系数表示法和点值表示法"><a href="#系数表示法和点值表示法" class="headerlink" title="系数表示法和点值表示法"></a>系数表示法和点值表示法</h3><p>我们知道，$n+1$ 个不同的点 $(x,y)$ 可以确定一个唯一的 $n$ 次多项式。</p><p>那么，给出 $n+1$ 个不同的坐标来表示一个多项式，称为<strong>点值表示法</strong>；将多项式写为 $f(x)=\sum_{i=0}^n a_ix^i$，称为<strong>系数表示法</strong></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>我们有以下想法：把两个函数转换为点值表示法，将对应的点值纵坐标相乘，最后再将它转换为系数表示法，就得到了它们的乘积。</p><p>例如，我们可以求出 $x\in[1,n+m+1]$ 时 $F(x)$ 和 $G(x)$ 的值，将对应的点值纵坐标相乘，就得到了它们乘积的点值表示法。然后我们就可以解出答案的各项系数。</p><p>但是，例子的时间复杂度最优只能做到 $O(n^2)$。我们需要找出一些特殊的点值，使得上述过程的时间复杂度降低。这里我们使用<strong>单位根</strong>。</p><p>求出一个 $n$ 次多项式在每个 $n$ 次单位根下的点值，被称为<strong>离散傅里叶变换</strong>（Discrete Fourier transform，DFT）。相反，用这些点值求出多项式各项系数的过程，被称为<strong>离散傅里叶逆变换</strong>（Inverse Discrete Fourier transform，IDFT）。</p><h3 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h3><p>假设我们有 $n$ 次多项式 $F(x)$，则我们要求出一个长度为 $n$ 的序列 $b$，其中 $b_i$ 表示 $F(x)$ 在 $n$ 次单位根的 $i$ 次幂下的点值，即：</p><script type="math/tex; mode=display">b_i=\sum_{j=0}^{n-1} a_j\times (\omega_n^i)^j</script><p>暴力做是 $O(n^2)$ 的，我们考虑用<strong>快速傅里叶变换</strong>（Fast Fourier Transform，FFT）来优化这个过程。</p><h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><p>我们考虑分治方法。</p><p>首先向 $A(x)$ 的最高次项添加 $0$，直到次数为 $2^k$。这样我们在分治的过程中可以将序列刚好分成两半。</p><p>设 $A$ 的各项系数为 $\{a_0,a_1,a_2,…,a_{n-1}\}$。</p><p>我们将所有偶数次项系数拿出来作为新函数 $A_0$，将所有奇数次项拿出来作为新函数 $A_1$，即：</p><script type="math/tex; mode=display">A_0(x)=a_0+a_2x+a_4x^2+a_6x^3+...+a_{n-2}x^{\frac{n}{2}-1}\\A_1(x)=a_1+a_3x+a_5x^2+a_7x^3+...+a_{n-1}x^{\frac{n}{2}-1}</script><p>容易得到 $A(x)=A_0(x^2)+xA_1(x^2)$。</p><p>我们先递归求出 $A_0$、$A_1$ 的变换结果，考虑如何由此推出 $A$ 的变换结果。</p><script type="math/tex; mode=display">A(\omega_n^k)=A_0(\omega_n^{2k})+\omega_n^kA_1(\omega_n^{2k})</script><p>单位根有性质 $\omega_n^k=\omega_{2n}^{2k}$，可以推出 $\omega_n^{2k}=\omega_{\frac{n}{2}}^{k}$。带入得：</p><script type="math/tex; mode=display">A(\omega_n^k)=A_0(\omega_{\frac{n}{2}}^{k})+\omega_n^kA_1(\omega_{\frac{n}{2}}^{k})</script><p>此时，如果 $k&lt;\frac{n}{2}$，则 $A_0(\omega_{\frac{n}{2}}^{k})$ 是 $A_0$ 变换结果的第 $k$ 项，$A_1(\omega_{\frac{n}{2}}^{k})$ 是 $A_1$ 变换结果的第 $k$ 项。由此我们可以求得 $A$ 变换结果的前 $\frac{n}{2}$ 项。</p><p>接下来我们求变换结果的后 $\frac{n}{2}$ 项。单位根有性质 $\omega_{n}^{k+\frac{n}{2}}=-\omega_n^k$。由 $A(x)=A_0(x^2)+xA_1(x^2)$ 可得，$A(-x)=A_0(x^2)-xA_1(x^2)$。所以可得：</p><script type="math/tex; mode=display">A(\omega_{n}^{k+\frac{n}{2}})=A(-\omega_n^k)=A_0(\omega_{\frac{n}{2}}^{k})-\omega_n^kA_1(\omega_{\frac{n}{2}}^{k})</script><p>这样我们就求出了 $A$ 的变换结果。时间复杂度 $O(n \log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span> n, complex&lt;<span class="type">double</span>&gt;* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>; </span><br><span class="line">    complex&lt;<span class="type">double</span>&gt; a0[n / <span class="number">2</span>], a1[n / <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">up</span>(<span class="number">0</span>, n / <span class="number">2</span> - <span class="number">1</span>, i) a0[i] = a[i * <span class="number">2</span>], a1[i] = a[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">FFT</span>(n / <span class="number">2</span>, a0), <span class="built_in">FFT</span>(n / <span class="number">2</span>, a1);</span><br><span class="line">    <span class="built_in">up</span>(<span class="number">0</span>, n / <span class="number">2</span> - <span class="number">1</span>, i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">x</span><span class="params">(cos(pi * <span class="number">2</span> * i / n), sin(pi * <span class="number">2</span> * i / n))</span></span>; <span class="comment">// 这个值是 w_n^k</span></span><br><span class="line">        a[i] = a0[i] + x * a1[i];</span><br><span class="line">        a[i + n / <span class="number">2</span>] = a0[i] - x * a1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>我们已经把两个多项式的乘积用点值表示法表示出来了，现在我们要把它转换为系数表示法。</p><p>假设我们已知离散傅里叶变换后的点值 ${b_i}$，我们想求多项式的系数 ${a_i}$。</p><p>先写公式：</p><script type="math/tex; mode=display">a_i=\frac{1}{n}\sum_{j=0}^{n-1}b_j\times\omega_n^{-ij}</script><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>由离散傅里叶变换的定义可得：</p><script type="math/tex; mode=display">b_i=\sum_{j=0}^{n-1} a_j\times \omega_n^{ij}</script><p>将 $b_i$ 带入到 $\sum_{j=0}^{n-1}b_j\times\omega_n^{-ij}$（即上述公式去掉 $\frac{1}{n}$）：</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=0}^{n-1}b_j\times\omega_n^{-ij}&=\sum_{j=0}^{n-1}\sum_{k=0}^{n-1} a_k\times \omega_n^{jk}\times \omega_n^{-ij}\\&=\sum_{j=0}^{n-1}\sum_{k=0}^{n-1} a_k\times \omega_n^{j(k-i)}\\&=\sum_{k=0}^n a_k\sum_{j=0}^{n-1}\omega_n^{j(k-i)}\\\end{aligned}</script><p>我们观察式子中的 $\sum_{j=0}^{n-1}\omega_n^{j(k-i)}$。此时分两种情况：</p><p>1、$i=k$</p><p>此时 $k-i=0$，所以：</p><script type="math/tex; mode=display">\sum_{j=0}^{n-1}\omega_n^{j(k-i)}=\sum_{j=0}^{n-1}1=n</script><p>2、$i \neq k$</p><p>此时 $\sum_{j=0}^{n-1}\omega_n^{j(k-i)}$ 可以看成等比数列求和的形式：</p><script type="math/tex; mode=display">\sum_{j=0}^{n-1}(\omega_n^{k-i})^j=\frac{1-(\omega_n^{k-i})^n}{1-\omega_n^{k-i}}</script><p>我么们观察分子中的 $(\omega_n^{k-i})^n$，它等于 $(\omega_n^n)^{k-i}$。单位根有性质 $\omega_n^n=1$，所以这个式子的值就是 $1$。所以：</p><script type="math/tex; mode=display">\sum_{j=0}^{n-1}\omega_n^{j(k-i)}=0</script><p>综上，我们可以得到：</p><script type="math/tex; mode=display">\sum_{j=0}^{n-1}b_j\times\omega_n^{-ij}=\sum_{k=0}^n a_k\sum_{j=0}^{n-1}\omega_n^{j(k-i)}=\sum_{k=0}^n a_k[i=k]\times n=n\times a_i</script><p>所以：</p><script type="math/tex; mode=display">\frac{1}{n}\sum_{j=0}^{n-1}b_j\times\omega_n^{-ij}=a_i</script><p>证毕。</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>如果把逆变换式子中的 $\frac{1}{n}$ 去掉，发现它与变换的公式很相似。正变换求 $\omega_n^i$ 的点值，而逆变换相当于求 $\omega_n^{-i}$ 的点值。逆变换的推导过程和正变换十分相似，这里就不再展开。它们最终的实现过程也很相似，我们可以把变换和逆变换放在同一个函数中。</p><p>逆变换后要记住将所有项除以 $n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span> n, complex&lt;<span class="type">double</span>&gt;* a, <span class="type">int</span> p)</span> <span class="comment">// p = 1 为正变换，p = -1 为逆变换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    complex&lt;<span class="type">double</span>&gt; a0[n / <span class="number">2</span>], a1[n / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) a0[i] = a[i * <span class="number">2</span>], a1[i] = a[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">FFT</span>(n / <span class="number">2</span>, a0, p), <span class="built_in">FFT</span>(n / <span class="number">2</span>, a1, p);</span><br><span class="line">    <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">z</span><span class="params">(cos(pi * <span class="number">2</span> / (p * n)), sin(pi * <span class="number">2</span> / (p * n)))</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若 p = 1，则此时 w = w_n^i</span></span><br><span class="line">        <span class="comment">// 若 p = -1，则此时 w = w_n^&#123;-i&#125;</span></span><br><span class="line">        <span class="comment">// 不要在这里直接求 w 的值，因为 sin 和 cos 的计算速度较慢</span></span><br><span class="line">        a[i] = a0[i] + w * a1[i];</span><br><span class="line">        a[i + n / <span class="number">2</span>] = a0[i] - w * a1[i];</span><br><span class="line">        w *= z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><p>递归实现的时间复杂度虽然正确，但是递归、动态开数组使得它的常数较大。我们要找到更优的实现方法。</p><p>假设 $n=8$，我们来模拟它的递归过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一层：0 1 2 3 4 5 6 7</span><br><span class="line">第二层：0 2 4 6|1 3 5 7</span><br><span class="line">第三层：0 4|2 6|1 5|3 7</span><br><span class="line">第四层：0|4|2|6|1|5|3|7</span><br></pre></td></tr></table></figure><p>递归过程的最底层是 <code>0 4 2 6 1 5 3 7</code>，我们来找它们的规律。我们先写出它们的二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000 100 010 110 001 101 011 111</span><br></pre></td></tr></table></figure><p>如果我们把这些二进制数翻转，就可以得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000 001 010 011 100 101 110 111</span><br></pre></td></tr></table></figure><p>转换为十进制，它们就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure><p>现在我们发现，最底层第 $i$ 位上的数字，就是 $i$ 二进制下翻转后的数字。</p><p>所以我们要求一个数组 $rev_i$，表示 $i$ 二进制下翻转后的数字。</p><p>$i$ 的二进制，可以用 $\lfloor\frac{i}{2}\rfloor$ 二进制左移一位，再加上 $[i \mod 2=1]$ 计算出。翻转后，我们可以得到：$rev_i$ 可以用 $rev_{\lfloor\frac{i}{2}\rfloor}$ 右移一位，再加上 $[i \mod 2 = 1]\times(n&gt;&gt;1)$ 计算出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_rev</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) rev[i] |= (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果仔细思考，就会发现，最底层的变换，其实就是第 $i$ 位与第 $rev_i$ 位的数字交换位置。</p><p>如果知道了最底层的数字，我们逐层向上合并即可。</p><p><a href="https://www.luogu.com.cn/problem/P3803">洛谷 P3803</a>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4000010</span>;</span><br><span class="line"><span class="type">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_rev</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) rev[i] |= (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span> n, complex&lt;<span class="type">double</span>&gt;* a, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (i &lt; rev[i]) <span class="built_in">swap</span>(a[i], a[rev[i]]); <span class="comment">// 将 a 按照最底层的数字排列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">2</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>) <span class="comment">//l：当前区间的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">z</span><span class="params">(cos(pi * <span class="number">2</span> / (p * l)), sin(pi * <span class="number">2</span> / (p * l)))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += l) <span class="comment">//i：区间左端点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; i + l / <span class="number">2</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                complex&lt;<span class="type">double</span>&gt; x = a[j] + w * a[j + l / <span class="number">2</span>], y = a[j] - w * a[j + l / <span class="number">2</span>];</span><br><span class="line">                a[j] = x, a[j + l / <span class="number">2</span>] = y;</span><br><span class="line">                w *= z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; a[N], b[N], c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, k = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(k &lt; n + m + <span class="number">1</span>) k *= <span class="number">2</span>; <span class="comment">// 找到第一个 &gt;= n + m + 1 的二的整数次幂</span></span><br><span class="line">    <span class="built_in">make_rev</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        a[i] = <span class="built_in">complex</span>&lt;<span class="type">double</span>&gt;(x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        b[i] = <span class="built_in">complex</span>&lt;<span class="type">double</span>&gt;(x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FFT</span>(k, a, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(k, b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) c[i] = a[i] * b[i];</span><br><span class="line">    <span class="built_in">FFT</span>(k, c, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m; i++) cout &lt;&lt; (<span class="type">int</span>)<span class="built_in">round</span>(c[i].<span class="built_in">real</span>() / k) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快速数论变换（NTT）"><a href="#快速数论变换（NTT）" class="headerlink" title="快速数论变换（NTT）"></a>快速数论变换（NTT）</h2><p>前置知识：FFT、原根。</p><p>在 FFT 中，我们用到了单位根处德点值，这就无法避免精度问题。在 NTT 中，我们放弃单位根，使用 <strong>原根</strong>。如果运算只涉及整数，或者结果要对 $998244353$ 这样的质数取模，就可以使用 NTT。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>我们可以取大质数 $p=998244353$，它的原根是 $g=3$。接下来的运算都在 $\mod p$ 的意义下。</p><p>对于 $n$（我们默认 $n$ 是二的整数次幂），我们设 $qn+1=p$，此时 $\omega_n=g^q$。也就是 $\omega_n=g^{\frac{p-1}{n}}$。</p><p>对于 $0\le i &lt; n$，我们要求 $\omega_n^i$ 处的点值。</p><h3 id="为什么原根可以代替单位根"><a href="#为什么原根可以代替单位根" class="headerlink" title="为什么原根可以代替单位根"></a>为什么原根可以代替单位根</h3><p>我们思考为什么可以使用单位根：</p><ol><li>对于 $0\le i &lt; n$，$\omega_n^i$ 互不相同。</li><li>$\omega_n^k=\omega_{2n}^{2k}$，用于变换。</li><li>$\omega_{n}^{k+\frac{n}{2}}=-\omega_n^k$，用于变换。</li><li>对于 $k\neq 0$，$\sum_{i=0}^{n-1}\omega_n^{ik}=0$，用于逆变换。</li></ol><p>如果此时 $\omega_n=g^q$，我们发现，上面的四条性质仍然成立！</p><h4 id="性质-1："><a href="#性质-1：" class="headerlink" title="性质 1："></a>性质 1：</h4><p>原根有性质：若 $p$ 为质数，则 $g^i \mod p$，$0\le i &lt; p-1$ 的结果两两不同。</p><p>所以 $1,g^{q},g^{2q},g^{3q}…$ 的结果互不相同。</p><h4 id="性质-2："><a href="#性质-2：" class="headerlink" title="性质 2："></a>性质 2：</h4><script type="math/tex; mode=display">\omega_n^k=g^{k\frac{p-1}{n}}=g^{2k\frac{p-1}{2n}}=\omega_{2n}^{2k}</script><h4 id="性质-3："><a href="#性质-3：" class="headerlink" title="性质 3："></a>性质 3：</h4><p>由费马小定理得：</p><script type="math/tex; mode=display">(\omega_n^{\frac{n}{2}})^2=\omega_n^n=g^{n\frac{p-1}{n}}=g^{p-1}\equiv 1\pmod p</script><p>所以 $\omega_n^{\frac{n}{2}}\equiv \pm 1\pmod p$。</p><p>根据性质一，$\omega_n^{\frac{n}{2}}\neq \omega_n^0=1$，所以 $\omega_n^{\frac{n}{2}}\equiv -1\pmod p$。</p><p>那么：</p><script type="math/tex; mode=display">\omega_{n}^{k+\frac{n}{2}}=\omega_{n}^k\times \omega_n^{\frac{n}{2}}=-\omega_{n}^k</script><h4 id="性质-4："><a href="#性质-4：" class="headerlink" title="性质 4："></a>性质 4：</h4><p>由等比数列求和公式得：</p><script type="math/tex; mode=display">\sum_{i=0}^{n-1}\omega_n^{ik}=\frac{1-(\omega_n^k)^n}{1-\omega_n^k}</script><p>在性质 3 得推到中，我们推出了 $\omega_n^n=1$，所以分子中的 $(\omega_n^k)^n=(\omega_n^n)^k=1$，所以原式的值是 $0$。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们可以直接在 FFT 代码上修改，把 $w_n$ 从单位根换成原根就可以了。不要忘记在运算过程中随时取模。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* a, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">up</span>(<span class="number">0</span>, n - <span class="number">1</span>, i) <span class="keyword">if</span> (i &lt; rev[i]) <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">2</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> z = <span class="built_in">qpow</span>(<span class="number">3</span>, (p - <span class="number">1</span>) / l);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span>) z = <span class="built_in">qpow</span>(z, p - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i += l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; i + l / <span class="number">2</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = (a[j] + <span class="number">1ll</span> * w * a[j + l / <span class="number">2</span>] % p) % p, y = (a[j] - <span class="number">1ll</span> * w * a[j + l / <span class="number">2</span>] % p + p) % p;</span><br><span class="line">                a[j] = x, a[j + l / <span class="number">2</span>] = y;</span><br><span class="line">                w = <span class="number">1ll</span> * w * z % p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它常用的模数"><a href="#其它常用的模数" class="headerlink" title="其它常用的模数"></a>其它常用的模数</h3><p>摘自 OI-Wiki。</p><script type="math/tex; mode=display">p=167772161=5\times2^{25}+1,g=3\\p=469762049=7\times2^{26}+1,g=3\\p=754974721=45\times2^{24}+1,g=11\\p=998244353=119\times 2^{23}+1,g=3\\p=1004535809=479\times 2^{21}+1,g=3</script><hr><h2 id="快速沃尔什变换（FWT）"><a href="#快速沃尔什变换（FWT）" class="headerlink" title="快速沃尔什变换（FWT）"></a>快速沃尔什变换（FWT）</h2><p>FWT 用于解决<strong>下标位运算卷积</strong>问题，形式为：给定两个序列 $A_i$ 和 $B_i$，求出序列 $C$，满足：</p><script type="math/tex; mode=display">C_i=\sum_{j\oplus k=i}A_jB_k</script><p>即 $A_jB_k$ 贡献在 $C$ 的第 $j\oplus k$ 位上。</p><p>其中 $\oplus$ 为位运算的某一种。通常为或、与、异或中的一种。</p><p>FWT 的核心思想是：对于一种运算，要找到一种构造方法。假设数组 $A$ 的构造结果是 $FWT[A]$，则需要满足 $FWT[C]_i=FWT[A]_i\times FWT[B]_i$。我们求出 $FWT[A]$ 和 $FWT[B]$，通过每一位的乘积求出 $FWT[C]$，最后通过逆变换求出 $C$。</p><h3 id="或"><a href="#或" class="headerlink" title="或"></a>或</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>我们要求：</p><script type="math/tex; mode=display">C_i=\sum_{j | k=i}A_jB_k</script><p>我们的构造方案是：</p><script type="math/tex; mode=display">FWT[A]_i=\sum_{j|i=i}A_j</script><p>即 $i$ 所有子集对应位置之和。</p><h4 id="构造正确性的证明"><a href="#构造正确性的证明" class="headerlink" title="构造正确性的证明"></a>构造正确性的证明</h4><script type="math/tex; mode=display">\begin{aligned}&~~~~~FWT[A]_i\times FWT[B]_i\\&= \sum_{j|i=i}A_j\times\sum_{k|i=i}B_k\\&= \sum_{j|i=i}~\sum_{k|i=i}A_jB_k\\&= \sum_{(j|k)|i=i}A_jB_k\\&= \sum_{x|i=i}~\sum_{j|k=x}A_jB_k\\&= \sum_{x|i=i}C_x\\&= FWT[C]_i\end{aligned}</script><h4 id="变换（FWT）"><a href="#变换（FWT）" class="headerlink" title="变换（FWT）"></a>变换（FWT）</h4><p>按照式子直接做是 $O(n^2)$ 的，无法接受。</p><p>我们考虑分治。假设当前有长度为 $2^k$ 的序列 $A_{0\sim 2^k-1}$，它的前半段为 $A_0$，后半段是 $A_1$。假设我们已经递归求出了 $FWT[A_0]$ 和 $FWT[A_1]$，考虑如何合并求出 $FWT[A]$。</p><p>有以下公式：</p><script type="math/tex; mode=display">FWT[A]=\operatorname{merge}(FWT[A_0],FWT[A_0]+FWT[A_1])</script><p>其中 $+$ 表示将序列的各位相加，$\operatorname{merge}$ 表示拼接两个序列。</p><p>这个公式的正确性大概比较显然吧（</p><h4 id="逆变换（IFWT）"><a href="#逆变换（IFWT）" class="headerlink" title="逆变换（IFWT）"></a>逆变换（IFWT）</h4><p>要求 $IFWT(FWT(A))=A$。把变换操作反过来即可。</p><script type="math/tex; mode=display">IFWT[A]=\operatorname{merge}(IFWT[A_0],IFWT[A_1]-IFWT[A_0])</script><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>两种操作只有最后一个符号不同，可以写在同一个函数中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FWT_or</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a0, a1, fwta0, fwta1, ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) a0.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() / <span class="number">2</span>; i &lt;= a.<span class="built_in">size</span>() - <span class="number">1</span>; i++) a1.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    fwta0 = <span class="built_in">FWT_or</span>(a0, k), fwta1 = <span class="built_in">FWT_or</span>(a1, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) ans.<span class="built_in">push_back</span>(fwta0[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) ans.<span class="built_in">push_back</span>(fwta1[i] + k * fwta0[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与"><a href="#与" class="headerlink" title="与"></a>与</h3><p>与操作与上文的或操作基本一致。</p><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p>我们要求：</p><script type="math/tex; mode=display">C_i=\sum_{j \& k=i}A_jB_k</script><p>我们构造：</p><script type="math/tex; mode=display">FWT[A]_i=\sum_{i|j=j}A_j</script><h4 id="构造正确性的证明-1"><a href="#构造正确性的证明-1" class="headerlink" title="构造正确性的证明"></a>构造正确性的证明</h4><script type="math/tex; mode=display">\begin{aligned}&~~~~~FWT[A]_i \times FWT[B]_i\\&= \sum_{i|j=j}A_j \times \sum_{i|k=k}B_k\\&= \sum_{i|j=j}~\sum_{i|k=k} A_jB_k\\&= \sum_{i|(k\&j)=(k\&j)} A_jB_k\\&= \sum_{i|x=x}~\sum_{k\&j=x} A_jB_k\\&= \sum_{i|x=x} C_x\\&= FWT[C]_i\end{aligned}</script><h4 id="变换（FWT）-1"><a href="#变换（FWT）-1" class="headerlink" title="变换（FWT）"></a>变换（FWT）</h4><script type="math/tex; mode=display">FWT[A]=\operatorname{merge}(FWT[A_0]+FWT[A_1],FWT[A_1])</script><h4 id="逆变换（IFWT）-1"><a href="#逆变换（IFWT）-1" class="headerlink" title="逆变换（IFWT）"></a>逆变换（IFWT）</h4><script type="math/tex; mode=display">IFWT[A]=\operatorname{merge}(IFWT[A_0]-IFWT[A_1],IFWT[A_1])</script><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FWT_and</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a0, a1, fwta0, fwta1, ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) a0.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() / <span class="number">2</span>; i &lt;= a.<span class="built_in">size</span>() - <span class="number">1</span>; i++) a1.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    fwta0 = <span class="built_in">FWT_and</span>(a0, k), fwta1 = <span class="built_in">FWT_and</span>(a1, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) ans.<span class="built_in">push_back</span>(fwta0[i] + k * fwta1[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) ans.<span class="built_in">push_back</span>(fwta1[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p>我们要求：</p><script type="math/tex; mode=display">C_i=\sum_{j \oplus k=i}A_jB_k</script><p>我们用 $x\circ y$ 表示 $\operatorname{popcount}(x\&amp;y)\mod 2$。</p><p>我们构造</p><script type="math/tex; mode=display">FWT[A]_i=\sum_{i\circ j=0}A_j - \sum_{i\circ j=1}A_j</script><h4 id="构造正确性证明"><a href="#构造正确性证明" class="headerlink" title="构造正确性证明"></a>构造正确性证明</h4><p>可以证明：</p><script type="math/tex; mode=display">(x\circ y)\oplus(x\circ z) = x \circ (y\oplus z)</script><p>所以：</p><script type="math/tex; mode=display">\begin{aligned}&~~~~~FWT[A]_i \times FWT[B]_i\\&= (\sum_{i\circ j=0}A_j - \sum_{i\circ j=1}A_j)(\sum_{i\circ k=0}B_k - \sum_{i\circ k=1}B_k)\\&= (\sum_{i\circ j=0}\sum_{i\circ k=0}A_jB_k+\sum_{i\circ j=1}\sum_{i\circ k=1} A_jB_k)-(\sum_{i\circ j=0}\sum_{i\circ k=1}A_jB_k+\sum_{i\circ j=1}\sum_{i\circ k=0}A_jB_k)\\&= \sum_{i\circ(j\oplus k)=0}A_jB_k-\sum_{i\circ(j\oplus k)=1}A_jB_k\\&= (\sum_{i\circ x=0}\sum_{j\oplus k=x}A_jB_k)-(\sum_{i\circ x=1}\sum_{j\oplus k=x}A_jB_k)\\&= \sum_{i\circ x=0}C_x-\sum_{i\circ x=1}C_x\\&= FWT[C]_i\end{aligned}</script><h4 id="变换（FWT）-2"><a href="#变换（FWT）-2" class="headerlink" title="变换（FWT）"></a>变换（FWT）</h4><script type="math/tex; mode=display">FWT[A]=\operatorname{merge}(FWT[A_0]+FWT[A_1],FWT[A_0]-FWT[A_1])</script><p>证明：</p><p>我们再观察式子：</p><script type="math/tex; mode=display">FWT[A]_i=\sum_{i\circ j=0}A_j - \sum_{i\circ j=1}A_j</script><ul><li>对于前半段的某个位置 $i$，当前二进制位的值是 $0$。那么 $j$ 当前二进制位的取值不会影响到 $i\circ j$ 的值。所以此时 $FWT[A]_i=FWT[A_0]_i+FWT[A_1]_i$。</li><li>对于前半段的某个位置 $i$，当前二进制位的值是 $1$。若 $j$ 在前半段，则 $j$ 当前二进制位的值是 $0$，不会影响到 $i\circ j$ 的值。若 $j$ 在后半段，则 $j$ 当前二进制位的值是 $1$，$i\circ j$ 就会相反。所以此时 $FWT[A]_i=FWT[A_0]_i-FWT[A_1]_i$。</li></ul><h4 id="逆变换（IFWT）-2"><a href="#逆变换（IFWT）-2" class="headerlink" title="逆变换（IFWT）"></a>逆变换（IFWT）</h4><script type="math/tex; mode=display">IFWT[A]=\operatorname{merge}(\frac{IFWT[A_0]+IFWT[A_1]}{2},\frac{IFWT[A_0]-IFWT[A_1]}{2})</script><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FWT_xor</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a0, a1, fwta0, fwta1, ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) a0.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() / <span class="number">2</span>; i &lt;= a.<span class="built_in">size</span>() - <span class="number">1</span>; i++) a1.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    fwta0 = <span class="built_in">FWT_xor</span>(a0, k), fwta1 = <span class="built_in">FWT_xor</span>(a1, k);</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) ans.<span class="built_in">push_back</span>(fwta0[i] + fwta1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) ans.<span class="built_in">push_back</span>(fwta0[i] - fwta1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) ans.<span class="built_in">push_back</span>((fwta0[i] + fwta1[i]) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i++) ans.<span class="built_in">push_back</span>((fwta0[i] - fwta1[i]) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="//post/string/"/>
      <url>//post/string/</url>
      
        <content type="html"><![CDATA[<h2 id="后缀自动机（SAM）"><a href="#后缀自动机（SAM）" class="headerlink" title="后缀自动机（SAM）"></a>后缀自动机（SAM）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>SAM 是一种很优秀的字符串数据结构。它可以将一个字符串的所有子串压缩成一个 $O(n)$ 大小的结构。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>SAM 是有限状态自动机，换种说法就是：</p><ul><li>SAM 是一个<strong>有向无环图</strong>。节点被称为<strong>状态</strong>。边有边权，权值为一个字母，边称为<strong>转移</strong>。</li><li>存在一个源点 $t_0$，即初始状态。从 $t_0$ 出发可以到达所有状态。</li><li>存在若干个终止状态。从 $t_0$ 到某个终止状态的路径，边权拼起来一定是 $s$ 的一个后缀。反之，$s$ 的任意一个后缀对应一条从 $t_0$ 到某个终止状态的路径。</li></ul><h3 id="SAM-与子串的关系"><a href="#SAM-与子串的关系" class="headerlink" title="SAM 与子串的关系"></a>SAM 与子串的关系</h3><p>从 $t_0$ 出发的任意一条路径，边权拼起来一定是 $s$ 的子串。反之，$s$ 的任意子串对应从 $t_0$ 出发的一条路径。</p><p>$t_0$ 到每个点可能有多条路径，也就是说每个状态对应一些子串的集合。</p><h3 id="引入其它概念"><a href="#引入其它概念" class="headerlink" title="引入其它概念"></a>引入其它概念</h3><h4 id="endpos"><a href="#endpos" class="headerlink" title="endpos"></a>endpos</h4><p>假设 $s$ 有非空子串 $t$，则 $\operatorname{endpos}(t)$ 表示 $t$ 在 $s$ 中所有出现的结束位置。例如 $s=\texttt{abcbc}$，则 $\operatorname{endpos}(\texttt{bc})=\{3,5\}$。</p><p>某几个子串的 $\operatorname{endpos}$ 可能相同，例如 $s=\texttt{abcbc}$，则 $\operatorname{endpos}(\texttt{c})=\operatorname{endpos}(\texttt{bc})=\{3,5\}$。$\operatorname{endpos}$ 相同的子串会被划分到同一个<strong>等价类</strong> 中， $s$ 的所有子串会被划分成若干个等价类。</p><p>SAM 的每个状态对应一个等价类中的所有子串。也就是说，SAM 的状态数为等价类的数量 $+1$，其中 $+1$ 加上的是 $t_0$，$t_0$ 对应的是空串。</p><blockquote><p><strong>引理 1</strong>：$u,w$ 是字符串的两个子串，则：$u$ 是 $w$ 的后缀 $\iff$ $\operatorname{endpos}(w) \subseteq \operatorname{endpos}(u)$。</p><p><strong>引理 2</strong>：在一个等价类中，短的字符串是长的字符串的后缀，且这些字符串长度连续。</p></blockquote><h4 id="后缀链接-link"><a href="#后缀链接-link" class="headerlink" title="后缀链接 link"></a>后缀链接 link</h4><p>现有状态 $u$，假设 $u$ 所对应的等价类中，长度最长的是 $t$。将 $t$ 的所有后缀按长度递减排序，则这个等价类中包含前几个后缀。设第一个<strong>不属于</strong>这个等价类的后缀为 $w$（一定存在，因为 $w$ 可以为空），则 $\operatorname{link}(u)$ 连向 $w$ 所属的等价类所对应的状态。</p><p>所有的后缀链接构成一棵根节点为 $t_0$ 的<strong>树</strong>。</p><p><strong>注意后缀链接 link 的边与 SAM 的边并不相同</strong>。</p><p>由引理 1 可知，$\operatorname{endpos}(u)\subsetneq\operatorname{endpos}(\operatorname{link}(u))$。</p><h4 id="其它定义"><a href="#其它定义" class="headerlink" title="其它定义"></a>其它定义</h4><p>对于状态 $u$，其等价类中最长的字符串为 $\operatorname{longest}(u)$，其长度为 $\operatorname{len}(u)$。最短的字符串为 $\operatorname{shortest}(u)$，其长度为 $\operatorname{minlen}(u)$。</p><p>可以得出：$\operatorname{minlen}(u)=\operatorname{len}(\operatorname{link}(u))+1$。</p><h3 id="SAM-的构建"><a href="#SAM-的构建" class="headerlink" title="SAM 的构建"></a>SAM 的构建</h3><p>我们采用在线构建方法，即向 SAM 中逐个加入字符。</p><p>先放代码（代码中 $t_0$ 节点的编号为 $1$）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">26</span>], len, link;</span><br><span class="line">    <span class="comment">// ch[x]: 从这个节点出发的，边权为 x 的边</span></span><br><span class="line">    <span class="comment">// len: 这个点对应的等价类中最长字符串的长度</span></span><br><span class="line">    <span class="comment">// link: 这个点的后缀链接</span></span><br><span class="line">&#125; t[N];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>, lst = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// tot 为 SAM 中点的总数</span></span><br><span class="line"><span class="comment">// lst 为 上一次操作过后整个串对应的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = lst, cur = ++tot;</span><br><span class="line">    t[cur].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !t[p].ch[x]) t[p].ch[x] = cur, p = t[p].link;</span><br><span class="line">    <span class="keyword">if</span> (!p) t[cur].link = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q = t[p].ch[x];</span><br><span class="line">        <span class="keyword">if</span> (t[p].len + <span class="number">1</span> == t[q].len) t[cur].link = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nw = ++tot;</span><br><span class="line">            t[nw] = t[q];</span><br><span class="line">            t[nw].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">            t[q].link = t[cur].link = nw;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; t[p].ch[x] == q) t[p].ch[x] = nw, p = t[p].link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lst = tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设已知字符串 $s$ 的 SAM，现在我们要添加字符 $x$，新的字符串为 $s+x$。</p><p>接下来我们看看 $\operatorname{add}$ 函数里代码的作用：</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p = lst, cur = ++tot;</span><br><span class="line">t[cur].len = t[p].len + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>$lst$ 指原串 $s$ 所属的节点，我们记录这个点为 $p$。</p><p>同时我们要新建一个节点，记这个节点为 $cur$。</p><p>新建节点也就意味着新建了一个等价类，显然这个等价类中最长的字符串为 $s+x$。所以可以求出 $\operatorname{len}(cur)=\operatorname{len}(p)+1$，即 $s$ 的长度 $+1$。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p &amp;&amp; !t[p].ch[x]) t[p].ch[x] = cur, p = t[p].link;</span><br></pre></td></tr></table></figure><p>在这个循环中，$p$ 会不停跳到 $\operatorname{link}(p)$，因此 $p$ 对应的字符串永远是原串 $s$ 的后缀。</p><p>循环的执行条件 <code>!t[p].ch[x]</code>，意为 $p$ 没有权值为 $x$ 的转移，也就是说 $p$ 中的字符串接上 $x$ 后都没有在原串中出现过。那么此时 $p$ 中所有的字符串接上 $x$ 后仍为同一个等价类，直接把状态 $p$ 添加一个权值为 $x$ 的转移，指向新的等价类 $cur$ 即可。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p) t[cur].link = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果遍历完原串 $s$ 的所有后缀，它们接上 $x$ 都没有在原串中出现过，那么 $s$ 的所有后缀接上 $x$ 都在同一个等价类中，它们的 $\operatorname{endpos}$ 都只有为 $|s|+1$ 这一个元素。直接将这个等价类的 $\operatorname{link}$ 指向 $t_0$ 即可。 </p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> q = t[p].ch[x];</span><br></pre></td></tr></table></figure><p>否则，我们在 $p$ 向上跳的过程中，找到了一个等价类，其中的字符串接上 $x$ 在原串中出现过。记 $q$ 为 $p$ 沿着权值为 $x$ 的转移走到的节点。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t[p].len + <span class="number">1</span> == t[q].len) t[cur].link = q;</span><br></pre></td></tr></table></figure><p>在这里我们做了一个判断：$\operatorname{len}(p)+1=\operatorname{len}(q)$。如果这个条件满足，说明等价类 $q$ 中只含有一个字符串，这个字符串即为 $\operatorname{longest}(p)+x$。此时将新建的等价类的 $\operatorname{link}$ 指向 $q$ 即可。</p><hr><p>否则，$\operatorname{len}(p)+1\neq\operatorname{len}(q)$。我们知道，$\operatorname{shortest}(q)=\operatorname{longest}(p)+x$。所以 $\operatorname{shortest}(q)$ 的 $\operatorname{endpos}$ 在原串的基础上增加了 $|s|+1$ 这一个值，而 $q$ 中其它字符串的 $\operatorname{endpos}$ 均未发生改变。</p><p>也就是说字符串加入 $x$ 后，$q$ 中的字符串的 $\operatorname{endpos}$ 不相同了。为了使每个节点的 $\operatorname{endpos}$ 相同，我们需要把 $q$ 拆分成两个等价类，一个只包含 $\operatorname{shortest}(q)$，另一个包含 $q$ 中的其他字符串。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nw = ++tot;</span><br><span class="line">t[nw] = t[q];</span><br><span class="line">t[nw].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">t[q].link = t[cur].link = nw;</span><br></pre></td></tr></table></figure><p>我们新建一个编号为 $nw$ 的节点，它只包含 $\operatorname{shortest}(q)$。它的出边和 $\operatorname{link}$ 应与原先 $q$ 的相同，所以先让 <code>t[nw] = t[q]</code>。现在的 $q$ 应包含除 $\operatorname{shortest}(q)$ 以外的字符串。</p><p>然后计算 $\operatorname{len}(nw)$，显然它等于 $\operatorname{len}(p)+1$。</p><p>最后，$q$ 和 $cur$ 的 $\operatorname{link}$ 都应连向 $nw$。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p &amp;&amp; t[p].ch[x] == q) t[p].ch[x] = nw, p = t[p].link;</span><br></pre></td></tr></table></figure><p>最后，$p$ 的某些后缀的权值为 $x$ 的转移可能指向 $q$，我们应该将他指向 $nw$。</p><p>至此，SAM 的就构建完了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何</title>
      <link href="//post/geometry/"/>
      <url>//post/geometry/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学</title>
      <link href="//post/maths/"/>
      <url>//post/maths/</url>
      
        <content type="html"><![CDATA[<p>一些学习数学的笔记，学了什么就写点什么，所以内容很杂（</p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>欧拉函数 $\varphi(n)$，表示小于等于 $n$ ，且与 $n$ 互质的数字个数。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>$n$ 为质数时，$\varphi(n)=n-1$。</li><li>是积性函数，即若 $a,b$ 互质，则有 $\varphi(ab)=\varphi(a)\varphi(b)$。其中比较特殊的是：当 $n$ 是奇数时，$\varphi(n)=\varphi(2n)$。</li><li>$n=\sum_{d|n}\varphi(d)$。</li><li>设分解质因数后 $n=\prod_{i=1}^sp_i^{k_i}$，则 $\varphi(n)=n\prod_{i=1}^s\frac{p_i-1}{p_i}$。</li></ul><h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><h4 id="单个欧拉函数的计算"><a href="#单个欧拉函数的计算" class="headerlink" title="单个欧拉函数的计算"></a>单个欧拉函数的计算</h4><p>根据上面的第四条性质，可以枚举 $n$ 的质因数进行计算，时间复杂度 $O(\sqrt n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(x); i++) <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res /= i, res *= (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">1</span>) res /= x, res *= (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="预处理前-N-个欧拉函数的值"><a href="#预处理前-N-个欧拉函数的值" class="headerlink" title="预处理前 N 个欧拉函数的值"></a>预处理前 N 个欧拉函数的值</h4><p>在线性筛的过程中，设 $n$ 的最小质因子为 $p_1$，设 $q=\frac{n}{p_1}$，则 $n$ 一定是通过 $p_1\times q$ 筛掉的。我们假设已经求出了 $\varphi(q)$ 的值，目标是推出 $\varphi(n)$。在这个过程中我们分两种情况：</p><p><strong>1. $q$ 是 $p_1$ 的倍数</strong></p><p>注意到此时 $n$ 和 $q$ 的质因子是相同的，那么：</p><script type="math/tex; mode=display">\varphi(q)=q\prod_{i=1}^s\frac{p_i-1}{p_i}</script><script type="math/tex; mode=display">\varphi(n)=n\prod_{i=1}^s\frac{p_i-1}{p_i}=p_1\times q\prod_{i=1}^s\frac{p_i-1}{p_i}=p_1\times \varphi(q)</script><p>即可推出 $\varphi(n)$ 的值。</p><p><strong>2. $q$ 不是 $p_1$ 的倍数</strong></p><p>此时 $q$ 与 $p_1$ 一定互质。欧拉函数是积性函数，可以用这条性质来推：</p><script type="math/tex; mode=display">\varphi(n)=\varphi(p_1\times q)=\varphi(p_1)\times\varphi(q)=(p_1-1)\times\varphi(q)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> np[N]; <span class="comment">// not prime</span></span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i])</span><br><span class="line">            prm.<span class="built_in">push_back</span>(i), phi[i] = i - <span class="number">1</span>; <span class="comment">// i 是质数，则 φ(i)=i-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : prm)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i * j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            np[i * j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * j] = j * phi[i]; <span class="comment">// 第一种情况</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * j] = phi[i] * (j - <span class="number">1</span>); <span class="comment">// 第二种情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>欧拉函数可以解决对一些 $\gcd$ 进行求和的问题。</p><p>利用性质：</p><script type="math/tex; mode=display">n=\sum_{d|n}\varphi(d)</script><p>可以得出：</p><script type="math/tex; mode=display">\gcd(a,b)=\sum_{d|\gcd(a,b)}\varphi(d)=\sum_{d|a,d|b}\varphi(d)</script><script type="math/tex; mode=display">\sum_{i=1}^n \gcd(i,n)=\sum_{i=1}^n\sum_{d|i,d|n}\varphi(d)=\sum_{d|n}\sum_{1\le i\le n,d|i}\varphi(d)=\sum_{d|n}\lfloor\frac{n}{d}\rfloor\varphi(d)</script><script type="math/tex; mode=display">\sum_{i=1}^n \sum_{j=1}^n \gcd(i,j)=\sum_{i=1}^n \sum_{j=1}^n\sum_{d|i,d|j}\varphi(d)=\sum_d\sum_{1\le i \le n,d|i}~\sum_{1\le j \le n,d|j} \varphi(d)=\sum_d\lfloor\frac{n}{d}\rfloor^2\varphi(d)</script><hr><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若 $\gcd(a,m)=1$，则 $a^{\varphi(m)} \equiv 1 \pmod{m}$。</p><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p>$\mu$ 是莫比乌斯函数：</p><script type="math/tex; mode=display">\mu(n)=\begin{cases}  1 & n=1 \\  0 & n有平方因子 \\  (-1)^k & 其它情况，设k为n本质不同的质因子个数 \\\end{cases}</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li>莫比乌斯函数是积性函数。</li><li>$\sum_{d|n}\mu(d)=[n=1]$。</li></ul><p>反演结论：$[\gcd(a,b)=1]=\sum_{d|\gcd(a,b)}\mu(d)$。</p><h3 id="莫比乌斯变换"><a href="#莫比乌斯变换" class="headerlink" title="莫比乌斯变换"></a>莫比乌斯变换</h3><p>设 $f(n),g(n)$ 是两个数论函数。若有 $f(n)=\sum_{d|n}g(d)$，则有：</p><ul><li>形式一：$g(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})$</li><li>形式二：$g(n)=\sum_{d|n}\mu(\frac{n}{d})f(d)$</li></ul><p>容易看出两种形式本质上是相同的。</p><hr><center>----------待更新----------</center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子</title>
      <link href="//post/ban-zi/"/>
      <url>//post/ban-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>除法和取模还没写完（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bigint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> neg;</span><br><span class="line">    vector&lt;<span class="type">short</span>&gt; num;</span><br><span class="line">    <span class="built_in">bigint</span>() &#123; neg = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">bigint</span>(vector&lt;<span class="type">short</span>&gt; vec)&#123; neg = <span class="number">0</span>; num = vec;&#125;</span><br><span class="line">    <span class="built_in">bigint</span>(vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; vec)&#123; <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) num.<span class="built_in">push_back</span>(i); neg = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">bigint</span>(<span class="type">int</span> x) &#123; <span class="keyword">if</span>(x &lt; <span class="number">0</span>) neg = <span class="number">1</span>, x = -x; <span class="keyword">while</span>(x) num.<span class="built_in">push_back</span>(x % <span class="number">10</span>), x /= <span class="number">10</span>; &#125;</span><br><span class="line">    <span class="built_in">bigint</span>(<span class="type">long</span> <span class="type">long</span> x) &#123; <span class="keyword">if</span>(x &lt; <span class="number">0</span>) neg = <span class="number">1</span>, x = -x; <span class="keyword">while</span>(x) num.<span class="built_in">push_back</span>(x % <span class="number">10</span>), x /= <span class="number">10</span>; &#125;</span><br><span class="line">    <span class="built_in">bigint</span>(string str) &#123; <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>) neg = <span class="number">1</span>, str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>()); <span class="keyword">else</span> neg = <span class="number">0</span>; <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)str.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) num.<span class="built_in">push_back</span>(str[i] - <span class="string">&#x27;0&#x27;</span>); (*<span class="keyword">this</span>).<span class="built_in">clearz</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> val)</span></span>&#123; <span class="keyword">while</span>((<span class="type">int</span>)num.<span class="built_in">size</span>() &lt;= pos) num.<span class="built_in">push_back</span>(<span class="number">0</span>); num[pos] = val; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123; <span class="keyword">while</span>((<span class="type">int</span>)num.<span class="built_in">size</span>() &lt;= pos) num.<span class="built_in">push_back</span>(<span class="number">0</span>); num[pos] += val; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearz</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span>(!num.<span class="built_in">empty</span>() &amp;&amp; num.<span class="built_in">back</span>() == <span class="number">0</span>) num.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">int</span> x) &#123; *<span class="keyword">this</span> = <span class="built_in">bigint</span>(x);&#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">long</span> <span class="type">long</span> x) &#123; *<span class="keyword">this</span> = <span class="built_in">bigint</span>(x);&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(bigint b) &#123; bigint a = *<span class="keyword">this</span>; <span class="keyword">return</span> a.neg == b.neg &amp;&amp; a.num == b.num; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(bigint b) &#123; bigint a = *<span class="keyword">this</span>; <span class="keyword">return</span> a.neg != b.neg ? (a.neg &amp;&amp; !b.neg) : (a.num.<span class="built_in">size</span>() != b.num.<span class="built_in">size</span>() ? (a.neg ? a.num.<span class="built_in">size</span>() &gt; b.num.<span class="built_in">size</span>() : a.num.<span class="built_in">size</span>() &lt; b.num.<span class="built_in">size</span>()) : (a.neg ? a.num &gt; b.num : a.num &lt; b.num)); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(bigint b) &#123; bigint a = *<span class="keyword">this</span>; <span class="keyword">return</span> !(a &lt; b || a == b); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(bigint b) &#123; bigint a = *<span class="keyword">this</span>; <span class="keyword">return</span> !(a == b); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(bigint b) &#123; bigint a = *<span class="keyword">this</span>; <span class="keyword">return</span> a &lt; b || a == b; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(bigint b) &#123; bigint a = *<span class="keyword">this</span>; <span class="keyword">return</span> a &gt; b || a == b; &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, bigint &amp;p) &#123; string str; is &gt;&gt; str; p = <span class="built_in">bigint</span>(str); <span class="keyword">return</span> is; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> bigint &amp;p) &#123; <span class="keyword">if</span>(p.neg) os &lt;&lt; <span class="string">&quot;-&quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i = p.num.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) os &lt;&lt; p.num[i]; <span class="keyword">if</span>(p.num.<span class="built_in">empty</span>()) os &lt;&lt; <span class="number">0</span>; <span class="keyword">return</span> os; &#125;</span><br><span class="line">    bigint <span class="keyword">operator</span>+(bigint b)</span><br><span class="line">    &#123;</span><br><span class="line">        bigint res;</span><br><span class="line">        bigint a = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.neg &amp;&amp; b.neg) res.neg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.neg)&#123; a.neg = <span class="number">0</span>; <span class="keyword">return</span> b - a;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b.neg)&#123; b.neg = <span class="number">0</span>; <span class="keyword">return</span> a - b;&#125;</span><br><span class="line">        vector&lt;<span class="type">short</span>&gt; x = a.num, y = b.num;</span><br><span class="line">        <span class="keyword">if</span>(x.<span class="built_in">size</span>() &gt; y.<span class="built_in">size</span>()) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">while</span>(x.<span class="built_in">size</span>() != y.<span class="built_in">size</span>()) x.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)x.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">add</span>(i, x[i] + y[i]);</span><br><span class="line">            <span class="keyword">if</span>(res.num[i] &gt;= <span class="number">10</span>)</span><br><span class="line">                res.<span class="built_in">add</span>(i + <span class="number">1</span>, <span class="number">1</span>), res.num[i] -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">clearz</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint <span class="keyword">operator</span>-(bigint b)</span><br><span class="line">    &#123;</span><br><span class="line">        bigint res;</span><br><span class="line">        bigint a = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (a.neg &amp;&amp; b.neg) a.neg = b.neg = <span class="number">0</span>, <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.neg)&#123; b.neg = <span class="number">1</span>; <span class="keyword">return</span> a + b;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b.neg)&#123; b.neg = <span class="number">0</span>; <span class="keyword">return</span> a + b;&#125;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) <span class="built_in">swap</span>(a, b), res.neg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a.num.<span class="built_in">size</span>() != b.num.<span class="built_in">size</span>()) b.num.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">short</span>&gt; x = a.num, y = b.num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)x.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">add</span>(i, x[i] - y[i]);</span><br><span class="line">            <span class="keyword">if</span>(res.num[i] &lt; <span class="number">0</span>) res.<span class="built_in">add</span>(i + <span class="number">1</span>, <span class="number">-1</span>), res.num[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">clearz</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span> k, complex&lt;<span class="type">double</span>&gt; *a, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        complex&lt;<span class="type">double</span>&gt; a1[mid], a2[mid];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mid; i++) a1[i] = a[i * <span class="number">2</span>], a2[i] = a[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">FFT</span>(mid, a1, t), <span class="built_in">FFT</span>(mid, a2, t);</span><br><span class="line">        <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">x</span><span class="params">(cos(acos(<span class="number">-1.0</span>) / mid), t * sin(acos(<span class="number">-1.0</span>) / mid))</span>, <span class="title">y</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mid; i++) &#123; complex&lt;<span class="type">double</span>&gt; xx = y * a2[i]; a[i] = a1[i] + xx; a[i + mid] = a1[i] - xx; y *= x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bigint <span class="keyword">operator</span> *(bigint b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= (<span class="type">int</span>)num.<span class="built_in">size</span>() + (<span class="type">int</span>)b.num.<span class="built_in">size</span>() - <span class="number">2</span>) k *= <span class="number">2</span>;</span><br><span class="line">        complex&lt;<span class="type">double</span>&gt; x[k], y[k], ans[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++) x[i] = <span class="built_in">complex</span>&lt;<span class="type">double</span>&gt;(num[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.num.<span class="built_in">size</span>(); i++) y[i] = <span class="built_in">complex</span>&lt;<span class="type">double</span>&gt;(b.num[i], <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">FFT</span>(k, x, <span class="number">1</span>), <span class="built_in">FFT</span>(k, y, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) ans[i] = x[i] * y[i];</span><br><span class="line">        <span class="built_in">FFT</span>(k, ans, <span class="number">-1</span>);</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; nw;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) nw.<span class="built_in">push_back</span>(<span class="built_in">round</span>(ans[i].<span class="built_in">real</span>() / k));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nw.<span class="built_in">size</span>(); i++) <span class="keyword">if</span> (nw[i] &gt;= <span class="number">10</span>) &#123; <span class="keyword">if</span> (i == nw.<span class="built_in">size</span>() - <span class="number">1</span>) nw.<span class="built_in">push_back</span>(<span class="number">0</span>); nw[i + <span class="number">1</span>] += nw[i] / <span class="number">10</span>; nw[i] %= <span class="number">10</span>;&#125;</span><br><span class="line">        <span class="function">bigint <span class="title">res</span><span class="params">(nw)</span></span>;</span><br><span class="line">        res.<span class="built_in">clearz</span>();</span><br><span class="line">        res.neg = neg ^ b.neg;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> +=(bigint b) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> -=(bigint b) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> - b; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> *=(bigint b) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> * b; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CCPC2024 辽宁省赛 游记</title>
      <link href="//post/ccpc-2024-youji/"/>
      <url>//post/ccpc-2024-youji/</url>
      
        <content type="html"><![CDATA[<p>省流：10 题，rk3。</p><p>队友：<a href="/user/747851">zyz</a>，<a href="/user/1077027">zys</a>，Orz。</p><p>萌新高中牲第一次打 xcpc（），好紧张。</p><h2 id="Day-1（热身赛）"><a href="#Day-1（热身赛）" class="headerlink" title="Day 1（热身赛）"></a>Day 1（热身赛）</h2><p>下午三点就到考点了，拍几张照，然后去食堂买了两杯喝的，休息一会。</p><p>热身赛六点开始，一共四道题。</p><p>先开 A，发现是 A+B，我切了。B 也是个水题，zys 切了。</p><p>C 也是个水题，我敲完代码交上去 WA 了，然后发现是个不输入 $T$ 的多测，改完交上去又 WA 了，最后发现没输出回车，改完交上去过了（）。</p><p>D 是个比较显然的树上 DP。zyz 几分钟就写完了，交上去 WA 了，然后我们三个人调了半个小时，WA 了十多发，最后发现是快速幂写挂了（（（。</p><p>耗时一个小时左右 AK，然后我们三个就润了。</p><p>总结：题都会做，但是犯了特别傻的错误，希望正式赛不要这么傻（</p><h2 id="Day-2（正式赛）"><a href="#Day-2（正式赛）" class="headerlink" title="Day 2（正式赛）"></a>Day 2（正式赛）</h2><p>8：30 开幕式，给赞助商打打广告，然后就是各种讲话。</p><p>9：20 比赛开始了，发现 B 是签，我切了。又发现 A 是个比较简单的字符串处理，我切了。zys 发现 J 是签，他切了。然后发现 C 是个简单的树上问题，开个 set 统计所有限制，贪心取符合条件的最小值即可，我切了。切完这四道题耗时 30min。</p><p>zyz 说 G 题似乎可做，我看了看，先想到双指针但是发现性质推假了，然后就想到用单调栈求出每个数字可以作为最大值的区间，然后向前跳 $k$ 个相同数字就可以了。41min 的时候我切了，拿到一血。</p><p>然后他们俩决定去打 D，我去休息一会。打了一会发现不太可做，此时我想到了 L 的做法，不是很难，推推性质然后二分就做完了。此时已经 81min 了。</p><p>zyz 推出了 E 的一些性质，103min 的时候他提交上去，发现 WA 了，我们三个人一起调了两分钟左右，然后工作人员把 E 题的气球送过来了（？？？），刷新一下发现刚才的提交从 WA 变成 AC 了（？？？？？？）。最后才知道评测系统出 bug 了，默认不使用 spj 测评，工作人员手动重测后才 AC（（（。</p><p>然后 zys 发现 D 其实是个诈骗，看似计算几何，实则n方的简单 dp 就能过。121min 时他切了。</p><p>工作人员把午饭送过来，是麦当劳，打开一看只有一个小汉堡和两个鸡翅，这够谁吃的啊 /fn /fn /fn</p><p>然后 zyz 发现 M 题是个大模拟，他就开始写了。180min 的时候提交，WA 了。</p><p>此时我 K 题有点思路，但是发现只有添加操作可以用 bitset 优化，删除操作则很烦人。zyz 想到可以用线段树分治，我觉得很有道理，然后就开始写了。代码不是很复杂，208min 的时候交了两发就过了。</p><p>封榜了，交了两发 I 都 tle 了。我觉得其它题应该是开不出来了，然后就决定三个人一起调 M。zys 造了个数据卡掉了原来的代码，然后就用这个数据调，最后发现有一处判断写错位置了，然后在 281min 的时候 AC 了。</p><p>剩 19 分钟结束，我们就摆了。最终做出 10 题。</p><p>赛后滚榜，获得了 rk3 的好成绩。高中队全面碾压大学（（（</p><p>rk1，rk2 都有noi银牌大佬，我们这个 1 铜牌 2 没牌的队伍能 rk3 已经很满意了。</p><p>但是打星队凭什么不给奖 /fn/fn/fn</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jbriz14o.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FHQ-Treap</title>
      <link href="//post/fhq-treap/"/>
      <url>//post/fhq-treap/</url>
      
        <content type="html"><![CDATA[<h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><p>Treap 是一种平衡树。每个点除了维护这个点的<strong>权值</strong>（$val$）以外，还维护一个随机的<strong>优先级</strong>（$priority$）。其中权值满足二叉搜索树的性质，优先级满足堆的性质，即：</p><ul><li>左子树权值 $\le$ 父节点权值 $\le$ 右子树权值（二叉搜索树性质）；</li><li>父节点优先级 $\le$ 子节点优先级（堆性质，如果使用小根堆）。</li></ul><p>若每个节点的优先级都随机生成，则树的形态也是随机的。一棵随机树的期望高度是 $O(\log n)$ 的，因此 Treap 的期望高度是 $O(\log n)$。</p><h2 id="FHQ-Treap"><a href="#FHQ-Treap" class="headerlink" title="FHQ-Treap"></a>FHQ-Treap</h2><p>FHQ-Treap（无旋式 Treap），通过开裂和合并，完成平衡树的操作，并保持树满足堆的性质。</p><p>接下来以 <a href="https://www.luogu.com.cn/problem/P3369">洛谷 P3369 普通平衡树</a> 为例，讲解 FHQ-Treap 的基本操作。</p><h3 id="定义节点"><a href="#定义节点" class="headerlink" title="定义节点"></a>定义节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> root, tot; <span class="comment">// 根节点编号、节点数量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val, pri; <span class="comment">// 权值、优先级</span></span><br><span class="line">    <span class="type">int</span> ls, rs; <span class="comment">// 左子树、右子树</span></span><br><span class="line">    <span class="type">int</span> siz; <span class="comment">// 子树大小</span></span><br><span class="line">&#125; t[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[o].siz = t[t[o].ls].siz + t[t[o].rs].siz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h3><p>将一棵 Treap 分裂成两棵树，第一棵树中的权值都 $\le k$，第二棵树中的权值都 $&gt;k$。</p><p>递归到节点 $x$ 时：</p><ul><li>若 $x$ 的权值 $\le k$，则 $x$ 和左子树都会被划分到第一棵树中，右子树的一部分被划分到第一棵树中，另一部分被划分到第二棵树中。</li><li>若 $x$ 的权值 $&gt; k$，则 $x$ 和右子树都会被划分到第二棵树中，左子树的一部分被划分到第一棵树中，另一部分被划分到第二棵树中。</li></ul><p><img src="/images/fhq-treap/1.png" alt=""></p><p>第一种情况：继续分裂 $x$ 的右子树，设分裂成 $p$ 和 $q$。将 $x$ 设为第一棵树的根，它的左子树不变，右子树设为 $p$。将 $q$ 设为第二棵树。 </p><p>第二种情况：继续分裂 $x$ 的左子树，设分裂成 $p$ 和 $q$。将 $x$ 设为第二棵树的根，它的右子树不变，左子树设为 $q$。将 $p$ 设为第一棵树。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> x,<span class="type">int</span> &amp;l,<span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!o)</span><br><span class="line">    &#123;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有标记，在这里push_down(o)</span></span><br><span class="line">    <span class="keyword">if</span>(t[o].val&lt;=x) </span><br><span class="line">    &#123;</span><br><span class="line">        l = o;</span><br><span class="line">        <span class="built_in">split</span>(t[o].rs, x, t[o].rs, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        r = o;</span><br><span class="line">        <span class="built_in">split</span>(t[o].ls, x, l, t[o].ls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_up</span>(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>假设现在有两棵 Treap $p,q$，且满足 $p$ 中所有节点的权值都小于等于 $q$ 中所有节点的权值，那么我们可以将这两棵树合并成一棵树。</p><p>合并的过程中要保持树满足堆的性质。所以我们要比较 $p$ 和 $q$ 的优先级大小。</p><ul><li>若 $p$ 优先级小，则 $p$ 作为新树的根，把 $p$ 的右子树和 $q$ 合并起来。</li><li>若 $q$ 优先级小，则 $q$ 作为新树的根，把 $q$ 的左子树和 $p$ 合并起来。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y)</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">if</span>(t[x].pri&lt;=t[y].pri)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果有标记，在这里push_down(x)</span></span><br><span class="line">        t[x].rs = <span class="built_in">merge</span>(t[x].rs, y);</span><br><span class="line">        <span class="built_in">push_up</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果有标记，在这里push_down(y)</span></span><br><span class="line">        t[y].ls = <span class="built_in">merge</span>(x, t[y].ls);</span><br><span class="line">        <span class="built_in">push_up</span>(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>假设我们要将 $x$ 插入到平衡树中。</p><p>我们可以先将平衡树分裂成 $l,r$，其中 $l$ 中所有节点权值都 $\le x$，$r$ 中所有节点权值都 $&gt; x$。</p><p>然后新建一个独立的节点，权值为 $x$。然后我们将 $l$、新建的节点、$r$ 合并起来，就做完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">new_node</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    t[tot].val = x;</span><br><span class="line">    t[tot].pri = <span class="built_in">rnd</span>(); <span class="comment">// 优先级取随机数</span></span><br><span class="line">    t[tot].siz = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">split</span>(root, x, l, r);</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">new_node</span>(x);</span><br><span class="line">    root = <span class="built_in">merge</span>(<span class="built_in">merge</span>(l, p), r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>假设我们要删除 $x$ 这个数字。</p><p>我们通过两次分裂操作，将平衡树分裂成三部分：$<x$、$=x$ 和 $>x$ 的部分。</p><p>我们可以删除 $=x$ 部分的任意一个节点。最方便的是删除这部分的根节点，将根节点的左右子树合并起来即可。</p><p>最后不要忘记将这三部分合并起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, p, r; <span class="comment">// 分别表示 &lt;x、=x、&gt;x 的部分</span></span><br><span class="line">    <span class="built_in">split</span>(root, x, l, r);</span><br><span class="line">    <span class="built_in">split</span>(l, x - <span class="number">1</span>, l, p);</span><br><span class="line">    p = <span class="built_in">merge</span>(t[p].ls, t[p].rs);</span><br><span class="line">    root = <span class="built_in">merge</span>(<span class="built_in">merge</span>(l, p), r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据值查询排名"><a href="#根据值查询排名" class="headerlink" title="根据值查询排名"></a>根据值查询排名</h3><p>操作等价于：给定 $x$，求比 $x$ 小的数字个数 $+1$。</p><p>那么我们可以将 $&lt;x$ 的部分分裂出来，然后查询这部分的大小即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">split</span>(root, x - <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="type">int</span> ans = t[l].siz;</span><br><span class="line">    root = <span class="built_in">merge</span>(l, r);</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据排名查询值"><a href="#根据排名查询值" class="headerlink" title="根据排名查询值"></a>根据排名查询值</h3><p>和二叉搜索树求第 $k$ 小值的方法差不多。将左子树的大小与 $k$ 比较，判断第 $k$ 小的节点在左子树中、在右子树中、还是在根节点上即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[t[o].ls].siz &gt; k - <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">kth</span>(t[o].ls, k); <span class="comment">// 第 k 小值在左子树中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[t[o].ls].siz == k - <span class="number">1</span>) <span class="keyword">return</span> t[o].val;  <span class="comment">// 第 k 小值为根节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[o].rs, k - t[t[o].ls].siz - <span class="number">1</span>);  <span class="comment">// 第 k 小值在右子树中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询前驱"><a href="#查询前驱" class="headerlink" title="查询前驱"></a>查询前驱</h3><p>即查询比 $&lt;x$ 的数字的最大值。</p><p>我们将 $&lt;x$ 的部分分裂出来，不停向右子树走就可以走到这部分的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">split</span>(root, x - <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="type">int</span> pos = l;</span><br><span class="line">    <span class="keyword">while</span>(t[pos].rs) pos = t[pos].rs; <span class="comment">//只要这个节点有右子树，就向右子树跳</span></span><br><span class="line">    <span class="type">int</span> ans = t[pos].val;</span><br><span class="line">    root = <span class="built_in">merge</span>(l, r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询后继"><a href="#查询后继" class="headerlink" title="查询后继"></a>查询后继</h3><p>与前期类似，我们查询的是 $&gt;x$ 的数字的最小值。</p><p>我们将 $&gt;x$ 的部分分裂出来，不停向左子树走就可以走到这部分的最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nxt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">split</span>(root, x, l, r);</span><br><span class="line">    <span class="type">int</span> pos = r;</span><br><span class="line">    <span class="keyword">while</span>(t[pos].ls) pos = t[pos].ls; <span class="comment">//只要这个节点有左子树，就向左子树跳</span></span><br><span class="line">    <span class="type">int</span> ans = t[pos].val;</span><br><span class="line">    root = <span class="built_in">merge</span>(l, r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center> ----------待更新---------- </center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S 2024 游记</title>
      <link href="//post/csp-s-2024-you-ji/"/>
      <url>//post/csp-s-2024-you-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-998244353"><a href="#Day-998244353" class="headerlink" title="Day -998244353"></a>Day -998244353</h2><p>初赛。</p><p>辽宁初赛晋级分数线一直极低，踩两脚答题卡就能晋级（），于是我赛前一套初赛题都没做，不慌（）。</p><p>教练没说要穿校服我就没穿，结果其他同学都穿了校服，借了一件校服拍张照片就进考场了。</p><p>难以想象 S 组有那么多小孩，大约有一半看上去像小孩的。我左面的小孩 30min 直接速通，开始扔矿泉水瓶子（）。1h 后小孩基本上都速通了，给我整懵了。</p><p>听说其它考场有小孩哼歌，幸好我的考场没有，但是 1h 过后全是矿泉水瓶和资料袋的声音。我正前方的小孩速通后用矿泉水瓶子用力砸自己的大腿，刚开始我没看清，还以为他在砸自己的**，给我吓坏了。</p><p>题做的比较顺利，难以想象一个锅都没有。</p><p>我把答案记在了准考证背面，出来后与洛谷置顶帖对答案，大约 70 分，稳过。后来发现全选 A 有 45 分，原来是致敬不可以总司令（），45 分在辽宁大概率能过的。</p><p>（upd：分数线是46分（），比前两年高了不少）</p><p>晚上与同学讨论，发现唐完了，至少有十多分是不该扣的。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>进考场，座位很密，热死了。</p><p>先看 T1，发现是签到，10 分钟过掉所有大样例，期望得分 $100$。</p><p>再看 T2，发现也是签到，直接二分出一堆区间贪心就行了，大约写了 20min 吧，期望得分 $100$。</p><p>T3，想到一个 $O(n^2a)$ 的 dp，$f_{i,j}$ 表示表示前 $i$ 个数，第 $i$ 个数是红色，最后一个蓝色的值为 $j$ 的答案。暴力转移。</p><p>然后调了好长时间，处理了一堆细节，唐完了。期望得分 $50$。</p><p>开始写 T4 时只剩 1h 了，想了个做法发现假了，于是只能写个暴力了，期望得分 $32$。</p><p>整场期望得分 $100+100+50+32=282$，但是感觉因为有两个签到，感觉没什么优势。希望能拿个蓝勾吧。</p><hr><p>赛后发现 T3，T4 全假了，分数大概是 $[200,282]$ 吧。</p><h3 id="Day-998244353-1"><a href="#Day-998244353-1" class="headerlink" title="Day 998244353"></a>Day 998244353</h3><p>查分，喜报，卡到上界了，282。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>矩阵幂求和</title>
      <link href="//post/ju-zhen-mi-qiu-he/"/>
      <url>//post/ju-zhen-mi-qiu-he/</url>
      
        <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定矩阵 $A$，求 $A+A^2+A^3+…+A^k$ 中每一个数字对 $p$ 取模的结果。</p><p>$n \le 30,k \le 10^9,p \le 10^4$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先把矩阵乘法、加法、快速幂写出来（不做讲解）。</p><p>然后写一个函数 $f(x)$，返回值为 $A+A^2+A^3+…+A^x$。</p><p>先用 $f(\lfloor x/2 \rfloor)$ 把 $A+A^2+A^3+…+A^{\lfloor x/2 \rfloor}$ 求出来。</p><p>假设 $res = f(\lfloor x/2 \rfloor)$，那么</p><script type="math/tex; mode=display">\begin{aligned}res \times A^{\lfloor x/2 \rfloor}&= (A+A^2+A^3+...+A^{\lfloor x/2 \rfloor}) \times A^{\lfloor x/2 \rfloor}\\&= A \times A^{\lfloor x/2 \rfloor}+A^2 \times A^{\lfloor x/2 \rfloor}+A^3 \times A^{\lfloor x/2 \rfloor}+...+A^{\lfloor x/2 \rfloor} \times A^{\lfloor x/2 \rfloor}\\&= A^{ {\lfloor x/2 \rfloor}+1}+A^{ {\lfloor x/2 \rfloor}+2}+A^{ {\lfloor x/2 \rfloor}+3}+...+A^{ {\lfloor x/2 \rfloor}+{\lfloor x/2 \rfloor} }\end{aligned}</script><p>这样就可以得出：</p><script type="math/tex; mode=display">\begin{aligned}res+res \times A^{\lfloor x/2 \rfloor}&=(A+A^2+A^3+...+A^{\lfloor x/2 \rfloor})+(A^{ {\lfloor x/2 \rfloor}+1}+A^{ {\lfloor x/2 \rfloor}+2}+A^{ {\lfloor x/2 \rfloor}+3}+...+A^{ {\lfloor x/2 \rfloor}+{\lfloor x/2 \rfloor} })\\&=A+A^2+A^3+...+A^{ {\lfloor x/2 \rfloor\times 2} }\end{aligned}</script><p>$\, \, \, \, \, \, \, \, res+res \times A^{\lfloor x/2 \rfloor}$</p><p>$=(A+A^2+A^3+…+A^{\lfloor x/2 \rfloor})+(A^{ {\lfloor x/2 \rfloor}+1}+A^{ {\lfloor x/2 \rfloor}+2}+A^{ {\lfloor x/2 \rfloor}+3}+…+A^{ {\lfloor x/2 \rfloor}+{\lfloor x/2 \rfloor} })$</p><p>$=A+A^2+A^3+…+A^{ {\lfloor x/2 \rfloor\times 2} }$</p><p>那么，当 $x$ 为偶数，$\lfloor x/2 \rfloor\times 2=x$，所以 $res+res \times A^{\lfloor x/2 \rfloor}$ 即为答案。</p><p>当  $x$ 为奇数，$\lfloor x/2 \rfloor\times 2=x-1$，所以 $res+res \times A^{\lfloor x/2 \rfloor}=A+A^2+A^3+…+A^{x-1}$，所以这个结果加上 $A^x$ 即为答案。</p><p>因为每次递归只需要求 $f(\lfloor x/2 \rfloor)$，所以时间复杂度为 $\mathcal{O}(\log k)$。</p><p>摆上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">matrix a;<span class="comment">//输入的矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> a;<span class="comment">//当x==1，答案就是a.</span></span><br><span class="line">    matrix res=<span class="built_in">f</span>(x/<span class="number">2</span>);<span class="comment">//求出f(⌊x/2⌋)</span></span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> res+(<span class="built_in">qpow</span>(a,x/<span class="number">2</span>)*res);<span class="comment">//当x为偶数，答案为res+res×A^⌊x/2⌋</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res+(res*<span class="built_in">qpow</span>(a,x/<span class="number">2</span>))+<span class="built_in">qpow</span>(a,x);<span class="comment">//否则答案就是 res+res×A^⌊x/2⌋+A^x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,k,p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line">    matrix <span class="keyword">operator</span> *(matrix b)<span class="comment">//矩阵乘法</span></span><br><span class="line">    &#123;</span><br><span class="line">        matrix res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.a[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.a[i][j]=(res.a[i][j]+a[i][k]*b.a[k][j])%p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    matrix <span class="keyword">operator</span> +(matrix b)<span class="comment">//矩阵加法</span></span><br><span class="line">    &#123;</span><br><span class="line">        matrix res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                res.a[i][j]=(a[i][j]+b.a[i][j])%p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">qpow</span><span class="params">(matrix a,<span class="type">int</span> k)</span><span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) res.a[i][j]=<span class="number">0</span>;<span class="comment">//清空</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res.a[i][i]=<span class="number">1</span>;<span class="comment">//把res变成单位矩阵</span></span><br><span class="line">    <span class="comment">//单位矩阵性质：一个矩阵乘以单位矩阵=这个矩阵。</span></span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matrix a;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> a;<span class="comment">//当x==1，答案就是a.</span></span><br><span class="line">    matrix res=<span class="built_in">f</span>(x/<span class="number">2</span>);<span class="comment">//求出f(⌊x/2⌋)</span></span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> res+(<span class="built_in">qpow</span>(a,x/<span class="number">2</span>)*res);<span class="comment">//当x为偶数，答案为res+res×A^⌊x/2⌋</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res+(res*<span class="built_in">qpow</span>(a,x/<span class="number">2</span>))+<span class="built_in">qpow</span>(a,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matrix ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) cin&gt;&gt;a.a[i][j],a.a[i][j]%=p;<span class="comment">//读入矩阵</span></span><br><span class="line">        </span><br><span class="line">    ans=<span class="built_in">f</span>(k);<span class="comment">//求出这个矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//直接输出矩阵就可以了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) cout&lt;&lt;ans.a[i][j]%p&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
